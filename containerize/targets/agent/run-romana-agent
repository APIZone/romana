#!/bin/bash

# Copyright (c) 2016 Pani Networks
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

usage() {
	echo "${0##*/}: entrypoint for romana services container."
	echo "Options:"
	echo " -h or --help: print usage"
	echo " --romana-root: URL for Romana Root service, eg: http://127.0.0.1:9600"
	echo " --interface: Interface for IP Address lookup, instead of eth0"
	echo " --nat: Add NAT rule for traffic coming from pods"
	echo " --nat-interface: Interface that NATs traffic, instead of eth0 or --interface setting."
	echo " --ipv6-tw: IPv6 interface configuration feature (default: empty. valid: disabled, prefix, address)."
	echo " --ipv6-tw-interface: network interface name to use as external IPv6 interface. Use with ipv6-tw=prefix|address."
	echo " --ipv6-tw-prefix: IPv6 prefix to use for autogenerated external IPv6 address. Use with ipv6-tw=prefix."
	echo " --ipv6-tw-address: IPv6 to use with external IPv6 interface. Use with ipv6-tw=address."
	echo " --cluster-ip-cidr: CIDR for cluster IPs. Excluded from NAT rule."
	echo " --pod-to-host: Permit pods to connect to the host server"
	echo " --node-name: Name used for nodes in the cluster. (default: hostname. valid values: hostname, fqdn)"
	echo " --cloud: Integration with cloud provider. (default: none. valid values: none, aws)"
}

# Parse command-line options
romana_root=
interface=
nat=
nat_interface=
ipv6_tw=disabled
ipv6_tw_interface=
ipv6_tw_prefix=
ipv6_tw_address=
cluster_ip_cidr=
pod_to_host=
cni_image="quay.io/romana/cni"
node_name=hostname
cloud=none
route_publisher=none
while [[ $1 == -* ]]; do
	# expand --foo=bar options
	if [[ $1 == -*=* ]]; then
		set -- "${1%%=*}" "${1#*=}" "${@:2}"
	fi
	case "$1" in
	-h|--help)
		usage
		exit 0
		;;
	--romana-root)
		romana_root="$2"
		shift 2
		;;
	--interface)
		interface="$2"
		shift 2
		;;
	--ipv6-tw)
		ipv6_tw="$2"
		shift 2
		;;
	--ipv6-tw-interface)
		ipv6_tw_interface="$2"
		shift 2
		;;
	--ipv6-tw-prefix)
		ipv6_tw_prefix="$2"
		shift 2
		;;
	--ipv6-tw-address)
		ipv6_tw_address="$2"
		shift 2
		;;
	--nat)
		nat="$2"
		shift 2
		;;
	--nat-interface)
		nat_interface="$2"
		shift 2
		;;
	--cluster-ip-cidr)
		cluster_ip_cidr="$2"
		shift 2
		;;
	--pod-to-host)
		pod_to_host="$2"
		shift 2
		;;
	--cni-image)
		cni_image="$2"
		shift 2
		;;
	--node-name)
		node_name="$2"
		shift 2
		;;
	--cloud)
		cloud="$2"
		shift 2
		;;
	--x-route-publisher)
		route_publisher="$2"
		shift 2
		;;
	*)
		echo "Unknown option '$1'"
		usage
		exit 1
		;;
	esac
done

usage_error() {
	if (($# < 1)); then
		internal_error "Call to usage_error without a message"
	fi
	echo "Error:" "$@"
	usage
	exit 1
}
	
internal_error() {
	echo "Internal Error:" "$@"
	exit 2
}

# Validate options provided
case "$node_name" in
hostname|fqdn)
	# OK
	;;
*)
	usage_error "Invalid value for --node-name: $node_name"
	;;
esac

case "$cloud" in
none|aws)
	# OK
	;;
*)
	usage_error "Invalid value for --cloud: $cloud"
	;;
esac

case "$route_publisher" in
bird)
	# OK
	;;
*)
	usage_error "Invalid value for --x-route-publisher: $route_publisher"
	;;
esac

# Validate ipv6-tw feature
case "$ipv6_tw" in
disabled|prefix|address)
	# OK
	;;
*)
	usage_error "Invalid value for --ipv6-tw: $ipv6_tw"
	;;
esac

# Validate ipv6-tw feature
if [[ "$ipv6_tw" != "disabled" ]]; then
	if [[ ! "$ipv6_tw_interface" ]]; then
		usage_error "ipv6-tw feature is enabled but required parameter is missing --ipv6-tw-interface."
	fi

	if ! ip link show "$ipv6_tw_interface" &>/dev/null; then
	       	usage_error "Provided interface $ipv6_tw_interface is not found."
	fi

	if [[ "$ipv6_tw" == "prefix" ]] && [[ ! "$ipv6_tw_prefix" ]]; then
		usage_error "ipv6_tw feature is enabled but required parameters are missing, expecting --ipv6-tw-prefix."
	fi

	if [[ "$ipv6_tw" == "address" ]]; then
		if  [[ ! "$ipv6_tw_address" ]] && [[ ! "$ipv6_tw_prefix" ]]; then
			usage_error "ipv6_tw feature is enabled but required parameters are missing, expecting --ipv6-tw-address and --ipv6-tw-prefix."
		fi
	fi
fi

# Romana Root is required. Use value from command-line, or look for environment variables from Kubernetes
if ! [[ "$romana_root" ]]; then
	if [[ "$ROMANA_ROOT_SERVICE_HOST" ]] && [[ "$ROMANA_ROOT_SERVICE_PORT_ROOT" ]]; then
		romana_root="http://$ROMANA_ROOT_SERVICE_HOST:$ROMANA_ROOT_SERVICE_PORT_ROOT"
	else
		usage_error "Romana Root URL must be provided."
	fi
fi

valid_bool() {
	if (($# != 1)); then
		internal_error "valid_bool(): expected 1 parameter, got $#"
	fi
	case "$1" in
	true|false)
		;;
	*)
		return 1
		;;
	esac
	return 0
}

# Check NAT option is valid
if [[ "$nat" ]]; then
	if ! valid_bool "$nat"; then
		usage_error "Expected 'true' or 'false' for --nat option. ('$nat')"
	fi
else
	nat=true
fi
# Check pod-to-host is valid
if [[ "$pod_to_host" ]]; then
	if ! valid_bool "$pod_to_host"; then
		usage_error "Expected 'true' or 'false' for --pod-to-host option. ('$pod_to_host')"
	fi
else
	pod_to_host=true
fi

# Validation functions
valid_number() {
	if (($# != 1)); then
		internal_error "valid_number(): expected 1 parameter, got $#"
	fi
	if ! printf "%d\n" "$1" &> /dev/null; then
		return 1
	fi
	return 0
}

valid_cidr() {
	if (($# != 1)); then
		internal_error "valid_cidr(): expected 1 parameter, got $#"
	fi
	# Split w.x.y.z/p into pieces.
	local w x y z p r v
	IFS='./' read -r w x y z p r <<< "$1"
	if [[ "$r" ]]; then
		# Additional data in the CIDR. Return error.
		return 1
	fi
	# Check w, x, y, z are valid numbers from 0-255.
	error=0
	for v in "$w" "$x" "$y" "$z"; do
		if ! valid_number "$v"; then
			error=1
			break
		fi
		if ! ((v >= 0 && v < 256)); then
			error=1
			break
		fi
	done

	if ((error)); then
		return 1
	fi
	# Check p is some value between 0 and 32.
	if ! valid_number "$p"; then
		return 1
	fi
	if ! ((p >= 0 && p <= 32)); then
		return 1
	fi
	
	# Passed checks. return OK
	return 0
}

# Networking functions
interface_address() {
	if (($# != 1)); then
		internal_error "interface_address(): expected 1 parameter, got $#"
		return $?
	fi
	if ! ip link show "$1" &>/dev/null; then
		return 1
	fi
	local found=0 first second
	while read -r first second _; do
		if [[ "$first" = "inet" ]]; then
			found=1
			break
		fi
	done < <(ip addr show "$1")
	if ! ((found)); then
		return 1
	fi
	printf "%s" "$second"
}

cidr_addr() {
	if (($# != 1)); then
		internal_error "cidr_addr(): expected 1 parameter, got $#"
	fi
	if ! valid_cidr "$1"; then
		internal_error "cidr_addr(): '$1' is not a valid CIDR."
	fi
	local a
	IFS='/' read -r a _ <<< "$1"
	printf "%s" "$a"
}

cidr_nw_addr() {
	if (($# != 1)); then
		internal_error "cidr_nw_addr(): expected 1 parameter, got $#"
	fi
	if ! valid_cidr "$1"; then
		internal_error "cidr_nw_addr(): '$1' is not a valid CIDR."
	fi
	local v w x y z p
	IFS='./' read -r w x y z p <<< "$1"
	((v=(w<<24) + (x<<16) + (y<<8) + z))
	((v=v>>32-p))
	((v=v<<32-p))
	printf "%d.%d.%d.%d" "$(((v>>24)%256))" "$(((v>>16)%256))" "$(((v>>8)%256))" "$((v%256))"
}
# Use eth0 as interface name if not provided
if ! [[ "$interface" ]]; then
	interface=eth0
fi

# Look up host IP
host_address=$(interface_address "$interface")
if ! [[ "$host_address" ]]; then
	internal_error "No address found for interface $interface"
fi
host_ip=$(cidr_addr "$host_address")
if ! [[ "$host_ip" ]]; then
	internal_error "Error extracting host IP from $host_address"
fi
host_nw=$(cidr_nw_addr "$host_address")
if ! [[ "$host_nw" ]]; then
	internal_error "Error extracting host network from $host_address"
fi

# Check Cluster IP CIDR is valid
if [[ "$cluster_ip_cidr" ]]; then
	if ! valid_cidr "$cluster_ip_cidr"; then
		usage_error "Expected valid CIDR for --cluster-ip-cidr. ('$cluster_ip_cidr')"
	fi
else
	usage_error "The cluster-ip-cidr option must be specified and match the kubernetes configuration."
fi

# Check if the route for the cluster-ip-cidr uses the host interface
if route_info=$(ip -o route get "$cluster_ip_cidr"); then
	# Look for the word 'dev'
	read -ra tokens <<< "$route_info"
	if (( ${#tokens[@]} )); then
		device_found=0
		for ((i=1; i < ${#tokens[@]} - 1; i++)); do
			if [[ "${tokens[i]}" = dev ]]; then
				device_found=1
				# If it'd route via a different interface, try to add
				# the correct route
				if [[ "${tokens[i+1]}" != "$interface" ]]; then
					if ip route add "$cluster_ip_cidr" dev "$interface"; then
						echo "Route added for $cluster_ip_cidr using device $interface"
					else
						echo "Failed to add route for $cluster_ip_cidr using device $interface"
					fi
				fi
				break
			fi
		done
		if ! (( device_found )); then
			echo "Failed to find device in route information for $cluster_ip_cidr"
		fi
	fi
else
	echo "Unable to look up route information for cluster-ip-cidr '$cluster_ip_cidr'"
fi

# Generate .romana.yml for romana cli tool
replacements=( -e 's|romana-root|'"$romana_root"'|g' )
sed "${replacements[@]}" /var/lib/romana/templates/dot-romana.template > /root/.romana.yml

# Install CNI
if [[ -d /host/usr/local/bin ]]; then
	cp /usr/local/bin/romana /host/usr/local/bin/romana
fi
if [[ -d /host/opt/cni/bin ]]; then
	replacements=(
		-e 's|cni-image|'"$cni_image"'|g'
		-e 's|node-name|'"$node_name"'|g'
	)
	sed "${replacements[@]}" /var/lib/romana/cni-installation/romana-cni-wrapper > /host/opt/cni/bin/romana
	chmod --reference=/var/lib/romana/cni-installation/romana-cni-wrapper /host/opt/cni/bin/romana
fi
if [[ -d /host/etc/cni/net.d ]]; then
	replacements=( -e 's|romana-root|'"$romana_root"'|g' )
	sed "${replacements[@]}" /var/lib/romana/cni-installation/10-romana.conf > /host/etc/cni/net.d/10-romana.conf
fi
if [[ -d /host/etc/romana ]]; then
	cp /root/.romana.yml /host/etc/romana/cli.yml
fi

# Check that we can reach root service. Keep trying for approximately 60s
intervals=(0 1 1 1 1 1 5 5 5 5 5 10 10 10)
succeeded=0
printf "Checking topology service is available from romana"
for i in "${intervals[@]}"; do
	sleep "$i"
	if romana host list &>/dev/null; then
		succeeded=1
		break
	else
		printf "."
	fi
done
if ! (( succeeded )); then
	usage_error "Unable to fetch list of hosts using '$romana_root' as root service"
fi
printf "ok\n"

# Check if this host is already configured
if ! host_info=$(romana host list -f json 2>/dev/null); then
	internal_error "romana host show command failed."
fi
if ! (( $(jq -r 'length' <<< "$host_info") )); then
	internal_error "no host information found"
fi

# Look up romana address using host ip
romana_host_info=$(romana host list -f json | jq -r --arg ip "$host_ip" '.[] | select(.ip==$ip) // empty')
if ! [[ "$romana_host_info" ]]; then
	internal_error "Unable to find host information for '$host_ip'"
fi
num_hosts=$(jq -s 'length' <<< "$romana_host_info")
if ! (( num_hosts )); then
	internal_error "Unable to find host information for '$host_ip'"
fi
if (( num_hosts != 1 )); then
	internal_error "Host information for '$host_ip' had $num_hosts results"
fi

# Extract romana address from host information
romana_address=$(jq -r '.romana_ip // empty' <<< "$romana_host_info")
if ! [[ "$romana_address" ]]; then
	internal_error "Unable to find romana_ip for '$host_ip'"
fi

# Get the topology config. Used for allocation and/or NAT
topology_path=$(curl -s "$romana_root" | jq -r '.links[] | select(.rel=="topology-config") | .href')
if ! [[ "$topology_path" ]]; then
	internal_error "empty result attempting to resolve topology-config"
fi
topology_config=$(curl -s "${romana_root}${topology_path}")
romana_cidr=$(jq -r '.config.datacenter.cidr // empty' <<< "$topology_config")
if ! valid_cidr "$romana_cidr"; then
	internal_error "invalid result attempting to get cidr configuration for topology"
fi

if [[ "$nat_interface" ]]; then
	nat_address=$(interface_address "$nat_interface")
	if ! [[ "$nat_address" ]]; then
		internal_error "No address found for NAT interface $nat_interface"
	fi
	nat_ip=$(cidr_addr "$nat_address")
	if ! [[ "$nat_ip" ]]; then
		internal_error "Error extracting NAT IP from $nat_address"
	fi
else
	# Use interface as default for nat_interface
	nat_interface="$interface"
	nat_ip="$host_ip"
fi

case "$nat" in
true)
	# Generate value for config option in supervisor template
	snat_exclusions="$romana_cidr,$cluster_ip_cidr"
	agent_environment='ROMANA_FEATURE_SNAT="enable",'
	agent_environment+='ROMANA_FEATURE_SNAT_NATIF="'"$nat_interface"'",'
	agent_environment+='ROMANA_FEATURE_SNAT_NATIP="'"$nat_ip"'",'
	agent_environment+='ROMANA_FEATURE_SNAT_EXCLUDE="'"$snat_exclusions"'"'
	;;
false)
	agent_environment=""
	;;
*)
	internal_error "nat variable was not true or false: '$nat'"
	;;
esac

case "$pod_to_host" in
true)
	if ! result=$(romana policy show permit-all-pod-to-host -f json); then
		internal_error "failed to look up existing policy"
	fi
	if ! (( $(jq -r length <<< "$result" ) )); then
		romana policy add /var/lib/romana/policies/permit-all-pod-to-host.json
	fi
	if ! result=$(romana policy show permit-all-host-to-pod -f json); then
		internal_error "failed to look up existing policy"
	fi
	if ! (( $(jq -r length <<< "$result" ) )); then
		romana policy add /var/lib/romana/policies/permit-all-host-to-pod.json
	fi
	;;
false)
	if ! result=$(romana policy show permit-all-pod-to-host -f json); then
		internal_error "failed to look up existing policy"
	fi
	if (( $(jq -r length <<< "$result" ) )); then
		romana policy remove permit-all-pod-to-host
	fi
	if ! result=$(romana policy show permit-all-host-to-pod -f json); then
		internal_error "failed to look up existing policy"
	fi
	if (( $(jq -r length <<< "$result" ) )); then
		romana policy remove permit-all-host-to-pod
	fi
	;;
*)
	internal_error "pod_to_host variable was not true or false: '$pod_to_host'"
	;;
esac

# Create agent database
printf "Creating database for agent\n"
/usr/local/bin/agent -rootURL "$romana_root" -createSchema
	
# Generate romana-agent.conf for supervisord
replacements=(
	-e 's|<romana-root>|'"$romana_root"'|g'
	-e 's|<interface>|'"$interface"'|g'
	-e 's|<agent-environment>|'"$agent_environment"'|g'
)
sed "${replacements[@]}" /var/lib/romana/templates/romana-agent.template > /etc/supervisor/conf.d/romana-agent.conf

# Configure route publisher
case "$route_publisher" in
bird)
	echo "Configuring route publisher (bird)"
	bird_conf_dir=/var/lib/romana/route-publisher/bird
	if ! [[ -d "$bird_conf_dir" ]]; then
		internal_error "Path for bird configuration templates not found: $bird_conf_dir"
	fi
	bird_conf_file="$bird_conf_dir/bird.conf"
	if ! [[ -f "$bird_conf_file" ]]; then
		internal_error "Path for bird configuration file not found: $bird_conf_file"
	fi
	bird_agent_template=
	if [[ -f "$bird_conf_dir/$host_ip.conf" ]]; then
		bird_agent_template="$bird_conf_dir/$host_ip.conf"
	elif [[ -f "$bird_conf_dir/$host_nw.conf" ]]; then
		bird_agent_template="$bird_conf_dir/$host_nw.conf"
	elif [[ -f "$bird_conf_dir/default.conf" ]]; then
		bird_agent_template="$bird_conf_dir/default.conf"
	else
		internal_error "Unable to find $host_ip.conf, $host_nw.conf or default.conf in $bird_conf_dir"
	fi
	if ! mkdir -p /var/run/romana/bird/conf.d; then
		internal_error "Unable to create config directory for bird: /var/run/romana/bird/conf.d"
	fi
	cp "$bird_conf_file" /var/run/romana/bird/bird.conf
	cp "$bird_agent_template" /var/run/romana/bird/agent-bgp.conf.t
	cp /var/lib/romana/templates/route-publisher-bird.template /etc/supervisor/conf.d/route-publisher-bird.conf
	;;
esac

# Run any required cloud integration agents
case "$cloud" in
aws)
	echo "Executing cloud integration stages for AWS"
	disable_srcdestcheck() {
		# Run fix-ec2-srcdestcheck. Ignore errors
		romana_aws_path=$(curl -s "$romana_root" | jq -r '.links[] | select(.rel=="romana-aws-config") | .href')
		if ! [[ "$romana_aws_path" ]]; then
			echo "empty result attempting to resolve romana-aws-config"
			return 1
		fi
		romana_aws_config=$(curl -s "$romana_root$romana_aws_path")

		romana_aws_host=$(jq -r '.common.api.host // empty' <<< "$romana_aws_config" )
		romana_aws_port=$(jq -r '.common.api.port // empty' <<< "$romana_aws_config" )
		if ! [[ "$romana_aws_host" ]]; then
			echo "invalid value for romana-aws host"
			return 1
		fi
		if ! [[ "$romana_aws_port" ]]; then
			echo "invalid value for romana-aws port"
			return 1
		fi
		romana_aws_url=$(printf "http://%s:%s" "$romana_aws_host" "$romana_aws_port")
		if /usr/local/bin/fix-ec2-srcdestcheck --romana-aws="$romana_aws_url"; then
			echo "EC2 SourceDestCheck disabled for instance"
		fi
	}
	disable_srcdestcheck
	;;
esac

if [[ "$ipv6_tw" != "disabled" ]]; then
	if ! grep -q ip6_tables /proc/modules; then
		internal_error "Failed to load kernel module for ip6tables, the module is required for ipv6_tw feature"
	fi

	if ! sysctl -p /etc/ipv6-tw-sysctl.conf; then
	       	internal_error "Failed to enabled sysctl configurations for ipv6_tw feature"
	fi

	address=
	IFS="/" read -r prefix size <<< "$ipv6_tw_prefix"
	if [[ "$ipv6_tw_address" ]]; then
		address="$ipv6_tw_address"
	else
		mac=$(ip link show $ipv6_tw_interface | tail -n1 | awk '{ print $2 }')
		mac_chars=$(wc -c <<< "$mac")
		if ! (($mac_chars == 18)); then
			internal_error "Failed to to detect mac address of an interface $ipv6_tw_interface"
		fi

		IFS=":" read -r a b c d e f <<< "$mac"
		address="${prefix}${c}${d}:${e}${f}/${size}"
	fi

	ip a add $address dev $ipv6_tw_interface
	# Error code=2 means address already configured.
	if ! (($? == 0 || $? == 2)); then
	       	internal_error "Failed to add address $address to the interface $ipv6_tw_interface"
	fi
	
	IFS="/" read -r address_only _ <<< "$address"
	nat_rule=( POSTROUTING -o $ipv6_tw_interface -j SNAT --to-source $address_only )

	if ! ip6tables -t nat -C ${nat_rule[@]}; then
		if ! ip6tables -t nat -A ${nat_rule[@]}; then
		       	internal_error "Failed to install nat rule for ipv6_tw feature ${nat_rule[@]}"
		fi
	fi

	# IPv6tw feature, propagate feature configuration into the CNI config
	IPV6_DS_TW=$ipv6_tw
	IPV6_DS_TW_PREFIX=$prefix
	IPV6_DS_TW_GATE=$address_only

	CNI_CONFIG=$(cat /host/etc/cni/net.d/10-romana.conf)
	JQ_ARGS=( --arg feature $ipv6_tw --arg prefix $prefix --arg gate $address_only )
	CNI_CONFIG=$(echo $CNI_CONFIG | jq ${JQ_ARGS[@]} '.ipv6_dual_stack_tw=$feature | .ipv6_dual_stack_tw_prefix=$prefix | .ipv6_dual_stack_tw_gate=$gate')
	[[ $? != 0 ]] && internal_error "Failed to propagate ipv6_tw feature into the CNI config"
	echo $CNI_CONFIG | jq '.' > /host/etc/cni/net.d/10-romana.conf

fi

# Run things via supervisord
printf "Launching Romana services via supervisord\n"
exec supervisord
